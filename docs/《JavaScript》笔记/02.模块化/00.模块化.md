---
title: 模块化
date: 2022-03-04 13:44:24
permalink: /pages/48c4b3/
categories:
  - 《JavaScript》笔记
  - 模块化
tags:
  - 
---

# 模块化

🌽 **模块化**：把复杂的系统分解到多个模块以方便编码

在 **模块化编程** 中，开发者将程序分解成离散功能块（discrete chunks of functionality），并称之为 **模块**。

- 将一个复杂的程序依据一定的规则（规范）封装成几个块（文件），并运行组合在一起。
- 块的内部数据相对而言是私有的，只是向外部暴露一些接口与外部其他模块通信。

每个模块具有比较完整，程序更小的接触面，使得校验、调试、测试轻而易举。精心编写的模块提供了可靠的抽象和封装界限，使得应用程序中每个模块都具有条理清楚的设计和明确的目的。


## 一. 模块化趋势

### 1.1 痛点

过去代码组织方式，会出现的问题：

- 命名空间冲突。
- 无法合理的管理项目依赖和版本。
- 无法方便控制依赖的加载顺序。
- 项目体积变大后难易维护。

### 1.2 优势

实现模块化能实现的优势：

- 方便代码维护。
- 提高代码复用性。
- 降低代码耦合度（解耦）。
- 分治思想。

## 二. 模块化进化史

### 2.1 全局模式

- `module1.js`

```js
// 数据
let data1 = 'module one data';

// 操作数据的函数
function foo() {
  console.log(`foo() ${data1}`);
}

function bar() {
  console.log(`bar() ${data1}`)
}
```

- `module2.js`

```js
let data2 = 'module two data';

function foo() {
  // 与模块1中的函数冲突了
  console.log(`foo() ${data2}`);
}
```

- `test.html`

```js
// 同步引入，若函数冲突，则后面覆盖前面
<script type="text/javascript" src="module1.js"></script>
<script type="text/javascript" src="module2.js"></script>

<script type="text/javascript">
  foo(); // foo() module two data
  bar(); // bar() module one data
</script>
```

**说明：**

- 全局模式：将不同的功能封装成不同的全局函数。
- 问题：全局变量被污染了，很容易引起命名冲突。

### 2.2 单例模式

- `module1.js`

```js
let moduleOne = {
  data: 'module one data',
  foo() {
    console.log(`foo() ${data}`);
  },
  bar() {
    console.log(`bar() ${data}`);
  }
}
```

- `module2.js`

```js
let moduleTwo = {
  data: 'module two data',
  foo() {
    console.log(`foo() ${data}`);
  },
  bar() {
    console.log(`bar() ${data}`);
  }
}
```

- `test.html`

```js
<script type="text/javascript" src="module1.js"></script>
<script type="text/javascript" src="module2.js"></script>

<script type="text/javascript">
  moduleOne.foo(); // foo() module one data
  moduleOne.bar(); // bar() module one data

  moduleTwo.foo(); // foo() module two data
  moduleTwo.bar(); // bar() module two data

  moduleOne.data = 'update data'; // 能直接修改模块内部的数据
  moduleOne.foo(); // foo() update data
</script>
```

**说明：**

- 单例模式：简单对象封装。
- 作用：减少了全局变量（如两个模块的 `data` 都不是全局变量了，而是对象的某一个属性）。
- 问题：不安全，可以直接修改模块内部的数据。

### 2.3 IIFE 模式

- `module1.js`

```js
(function(window) {
  // 数据
  let data = 'IIFE module data';
  
  // 操作数据的函数
  function foo() {
    // 用于暴露的函数
    console.log(`foo() ${data}`);
  }
  
  function bar() {
    // 用于暴露的函数
    console.log(`bar() ${data}`);
    otherFun(); // 内部调用
  }
  
  function otherFun() {
    // 内部私有函数
    console.log(`privateFunction go otherFun()`);
  }
  
  // 暴露 foo 函数和 bar 函数
  window.module = { foo, bar };
})(window);
```

- `test.html`

```js
<script type="text/javascript"></script>

<script type="text/javascript">
  module.foo(); // foo() IIFE module data
  module.bar(); // bar() IIFE module data    privateFunction go otherFun()
  
  // module.otherFun(); // 报错，module.otherFun is not a function
  
  console.log(module.data); // undefined 因为我暴露的 module 对象中五 data
  module.data = 'xxx'; // 不是修改的模块内部的 data，而是在 module 新增 data 属性
  module.foo(); // 验证内部的 data 没有改变，还是会输出 foo() IIFE module data
</script>
```

**说明：**

- IIFE 模式：匿名函数自调用（闭包）。
- IIFE：Immediately-Invoked Function Expression（立即调用函数表达式）。
- 作用：数据是私有的，外部只能通过暴露的方法操作。
- 问题：如果当这个模块依赖另一个模块怎么办？见下面 IIFE 增强版的（模块依赖于 jQuery）。

### 2.4 IIFE 模式增强

引入 jQuery 到项目中

- `module1.js

```js
(function(window, $) {
  // 数据
  let  data = 'IIFE Strong module data';
  
  // 操作数据的函数
  function foo() {
    // 用于暴露的函数
    console.log(`foo() ${data}`);
    $('body').css('background', 'red');
  }
  
  function bar() {
    // 用于暴露的函数
    console.log(`bar() ${data}`);
    otherFun(); // 内部调用
  }
  
  function otherFun() {
    // 内部私有函数
    console.log('privateFunction go otherFun()');
  }
  
  // 暴露 foo 函数和 bar 函数
  window.moduleOne = { foo, bar };
})(window, jQuery);
```

- `test.html`

```js
<!--引入的js必须有一定顺序-->
<script type="text/javascript" src="jquery-1.10.1.js"></script>
<script type="text/javascript" src="module1.js"></script>

<script type="text/javascript">
  moduleOne.foo(); //foo() IIFE Strong module data  而且页面背景会变色
</script>
```

说明：

- IIFE 模式增强：引入依赖。
- 这就是现代模块实现的基石。其实很像了，有引入和暴露两个方面。
- 存在的问题：一个页面需要引入多个 JS 文件的问题。

```js
<script type="text/javascript" src="module1.js"></script>
<script type="text/javascript" src="module2.js"></script>
<script type="text/javascript" src="module3.js"></script>
<script type="text/javascript" src="module4.js"></script>
```

- 请求过多：一个 `<script>` 标签就是一次请求。
- 依赖模糊：看不出来谁依赖着谁？哪些模块是有依赖关系的，很难看出来。
- 难易维护：内部依赖关系混乱也就难以维护拉。

## 三. 模块化方案

### 3.1 CommonJS

CommonJS 是服务器端模块的规范，Node.js 就是采用了这个规范。但目前也可用于浏览器端，需要使用 Browserify 进行提前编译打包。

CommonJS 模块化的引入方式使用 `require`，暴露的方式使用 `module.exports` 或 `exports`。

![javascript_03-04_01](https://cdn.jsdelivr.net/gh/oliver556/image-hosting@master/20220304/javascript_03-04_01.6j4h2qfk1dw0.webp)

**特点：**

- 同步加载依赖的模块。
- 可复用于 Node 环境。
- 成熟的第三方模块社区。

> 彻底说明白 `module.exports` 和 `exports` 的区别：

在 Node.js 中，`module` 是一个全局变量，类似于在浏览器端的 window 也是一个全局变量一样的道理。

`module.exports` 初始化的时候置为空对象，`exports` 也指向这个空对象。

内部代码实现：

```js
var module = {
  id: 'xxx',
  exports: {}
};

var exports = module.exports;
// exports 是对 module.exports 的引用。
// 也就是 exports 现在指向的内存地址和 module.exports 指向的内存地址是一样的。
```

上面的代码可以看出我们平常使用的 `exports` 是对 `module.exports` 的一个引用，两者都是指向同一个对象。

用一句话来说明就是，模块的 `require`（引入）能看到的只有 `module.exports` 这个对象，它是看不到 `exports` 对象的，而我们在编写模块时用到的 `exports` 对象实际上只是对 `module.exports` 的引用。

```js
exports = module.exports;
```

我们可以使用 `exports.a = 'xxx'` 或 `exports.b = function(){}` 添加方法或属性，本质上它也添加在 `module.exports` 所指向的对象身上。

但是你不能直接 `exports = { a: 'xxx };`，这就将 `exports` 重新指向新的对象，它和 `module.exports` 就不是指向同一个对象，也就让两者失去了关系，而 Node.js 中，`require` 能看到的是 `module.exports` 指向的对象。

因此，我们一般都会直接使用：

```js
module.exports;
```

再举例说明两者区别：

```js
function foo() {
  console.log('foo');
}

function bar() {
  console.log('bar');
}
```

想要将这两个函数暴露出去，可以直接使用 `exports`。

```js
exports.foo = foo;
exports.bar = bar;
```

也可以对 `module.exports` 赋值

```js
module.exports = {
  foo: foo,
  bar: bar,
};
```

但是不能直接对 `exports` 赋值

```js
// 错误
exports = {
  foo: foo,
  bar: bar,
};
```

因为这样做仅仅改变了 `exports` 的引用，而不改变 `module.exports`。

**总结：**

**特点：** 同步加载，有缓存

**用法：** 关键在于引入和暴露

- 引入模块
  - `require(url)（`url` 为路径参数）
  - 路径：自定义模块路径必须以 `./` 或者 `../` 开头
  - 第三方模块 / 内置模块 / 核心模块：路径直接使用模块名称
- 暴露模块
  - `exports`
  - `module.exports`

主要是在服务器端使用的，但是也能在浏览器端运行，需要借助 [Browserify](https://github.com/browserify/browserify) 进行编译。

### 3.2 AMD

> CommonJS 规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。由于 NodeJS 主要用于服务器编程，模块文件一般都已经存在于本地硬盘，所以加载起来比较快，所以同步加载没有问题。  
> 但是如果是浏览器端，同步加载很容易阻塞，这时候 AMD 规范就出来了。AMD 规范则是非同步加载模块，允许指定回调函数。故浏览器端一般会使用 AMD 规范。

[AMD](https://github.com/amdjs/amdjs-api/wiki) 是 [require.js](https://github.com/requirejs/requirejs) 在推广过程中对模块定义的规范化产出。

![javascript_03-04_02](https://cdn.jsdelivr.net/gh/oliver556/image-hosting@master/20220304/javascript_03-04_02.65utps3i5ps0.webp)

**特点：**

- 异步加载依赖的模块
- 可在不转换代码的情况下直接在浏览器运行
- 并行加载多个模块
- 可运行在浏览器和 Node 环境

**用法：**

- 暴露模块
  - 在模块内部使用 `return`
- 定义模块
  - `define(['模块名'], function (模块暴露内容) {})`
  - `require(['模块名'], function (模块暴露内容) {})`
- 主模块
  - `requirejs.config({})` 配置使用的模块路径
  - `requirejs(['模块名'], function (模块暴露内容) {})`
- HTML 文件引入 <script> 标签
  - `<script data-main='app.js' src='require.js'></script>`

AMD（通用模块定义）主要是在浏览器使用的。

### 3.3 CMD



